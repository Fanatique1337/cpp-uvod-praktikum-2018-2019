#include <iostream>

/*
4. Да се въведе от клавиатурата положително 4-цифрено цяло число. Да се провери 
дали числото е палиндром. Палиндромът е една или няколко думи или числа, 
които се четат по един и същ начин от ляво надясно и от дясно наляво.
Примерен вход и изход на програмата:
       2112 -> true
       2114 -> false
*/

int main()
{
	// Дефинираме си всички променливи с първоначална стойност 0.
	int number, digit, temp, reverse_number = 0;

	std::cout << "Enter a number: " << std::endl;
	std::cin >> number;

	/* Използваме една "временна" променлива, в която да съхраняваме числото.
	(тя е копие на числото, работим с нея, 
	за да не променяме първоначалното число)
	*/
	temp = number;

	/*
	while e цикъл. Условието е в скобите и логиката му е както следва:
	Ако УСЛОВИЕ е изпълнено, тогава кода на while ще се изпълнява 
	отново и отново, докато УСЛОВИЕ стане грешно.
	В този случай, while цикъла ще се изпълнява докато 
	променливата temp не е равна на 0.
	Когато променливата стане 0, цикъла ще спре да се изпълнява.
	while прави проверка на условието в началото на цикъла 
	(при всяко зацикляне). В нашият случай, while първо ще провери дали 
	temp е различно от 0. Ако е различно от 0, ще запази остатъка от делението
	на temp с 10 (което е една цифра) в променливата digit.
	След това на променливата reverse_number ще присвоим стойноста на 
	същата променлива умножена по 10, плюс цифрата от променливата digit.
	temp се разделя на 10 и си запазва новата стойност 
	(temp /= 10 представлява temp = temp / 10).
	След това УСЛОВИЕто отново се проверява дали е вярно, и ако е вярно,
	продължаваме.

	Представеното от мен в цикъла е алгоритъм за обръщане на едно число.
	Първо взимаме последната цифра на това число и я прибавяме към
	обратното число, а първоначалното число разделяме на 10.
	Взимаме следващата цифра, прибавяме я към обратното число, което
	предварително умножаваме по 10 и отново разделяме първоначалното
	на 10. И така докато първоначалното число не стане 0.

	Изглежда сложно, но ето един пример:
	Въвеждаме числото 2114.
	Числото 2114 е различно от 0 и влизаме в цикъла:
	digit = 2114 % 10 = 4.
	reverse_number = (0 * 10) + 2 = 4.
	temp = 2114 / 10 = 211. (int е за цели числа, няма дроби)
	
	И започваме отново, temp e 211, което е различно от 0, продължаваме:
	digit = 211 % 10 = 1;
	reverse_number = (2 * 10) + 1 = 41;
	temp = 211 / 10 = 21;
	
	Трети цикъл, temp e 21, което е различно от 0, продължаваме:
	digit = 21 % 10 = 1;
	reverse_number = (21 * 10) + 1 = 411;
	temp = 21 / 10 = 2;

	temp e 2, различно е от 0, продължаваме:
	digit = 2 % 10 = 2;
	reverse_number = (211 * 10) + 2 = 4112;
	temp = 2 / 10 = 0;

	temp e 0, спираме дотук.
	И ето, че сме получили reverse_number = 4112.
	*/
	while (temp != 0)
	{
		digit = temp % 10;
		reverse_number = (reverse_number * 10) + digit;
		temp /= 10;
	}

	/*
	Проверяваме дали обърнатото число е равно на първоначалното,
	ако е, значи то е палиндром.
	*/
	if (reverse_number == number)
		std::cout << "true" << std::endl;
	else
		std::cout << "false" << std::endl;

	return 0;
}